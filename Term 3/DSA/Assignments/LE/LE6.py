# -*- coding: utf-8 -*-
"""Copy of LE6_Graphs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pVz5Ai-tSzsISNsJjyhe46NCFccB2Hzi
"""

# Lab Exercise 6

# Suggestion : Use Adjacency List representation of Graphs
# But feel free to use any representation

from collections import defaultdict
import sys


# Create your own Heap class with methods useful for finding shortest path
class Heap():

	def __init__(self, maxsize=1000):
		self.maxsize = maxsize
		self.array = [0]*(self.maxsize+1)
		self.size = 0
		self.pos = [None]*(self.maxsize+1)
		self.pos[0] = None
		self.array[0] = -1 * sys.maxsize
		self.FRONT = 1

 # minHeapify method to minHeapify the node at pos
	def minHeapify(self, posn):
		start_index = posn
		while True:
			if 2*start_index > self.size:
				break
			elif 2*start_index+1 > self.size:
				min_ind = min([start_index, 2*start_index], key=lambda x:self.array[x])
			else:
				min_ind = min([start_index, 2*start_index, 2*start_index+1], key=lambda x:self.array[x])
			
			if min_ind == start_index:
				break
			self.array[min_ind], self.array[start_index] = self.array[start_index], self.array[min_ind]
			self.pos[min_ind], self.pos[start_index] = self.pos[start_index], self.pos[min_ind]
			start_index = min_ind


	# Write this function to insert a node into the heap
	def insert(self, posn, element):
		if self.size == self.maxsize:
			print('Heap is full')
			return
		self.size+=1
		self.array[self.size] = element
		self.pos[self.size] = posn
		

		x = self.size//2
		while x>=1:
			self.minHeapify(x)
			x=x//2


	# Write this function to delete the rootNode
	def delete(self):
		if self.isPqEmpty():
			print('Heap is empty')
			return
		
		self.array[self.size], self.array[1] = self.array[1], self.array[self.size]
		self.pos[self.size], self.pos[1] = self.pos[1], self.pos[self.size]
		root_val, pos_root_val = self.array[self.size], self.pos[self.size]
		self.array[self.size] = 0
		self.pos[self.size] = None
		self.size-=1
		self.minHeapify(1)
		# return (pos_root_val, root_val)
		
		

	# Write this function to return the rootNode (here the minimum element in PQ)
	def minimumElement(self): 
		return (self.pos[self.FRONT], self.array[self.FRONT])

	# Write this function to return the size of the PriorityQueue
	def sizeOfPq(self): 
		return self.size

	# Write this function to return if the priorityQueue is empty or not
	# Return boolean value
	def isPqEmpty(self):
		return self.size<=0

	# Function to print the contents of the heap
	def printPriorityQueue(self):
		for i in range(1, (self.size//2)+1):
			print("Parent : "+ str(self.array[i])+" Left Child : "+
								str(self.array[2 * i])+" Right Child : "+
								str(self.array[2 * i + 1]))

# Utility Function to print the shortest distances to the nodes
# from the source point
def printArr(dist):
	print ("Vertex\tDistance from source")
	for i in range(len(dist)):
		print ("%d\t\t%d" % (i, dist[i]))


class Graph():

	def __init__(self, V):
    # You can use the below dictionary for adjacency list representation
		self.V = V
		self.graph = defaultdict(lambda: None)

   # Adds an edge to an undirected graph
	def addEdge(self, src, dest, weight):
		if self.graph[src]:
			self.graph[src][dest] = weight
		else:
			self.graph[src] = defaultdict(lambda: None)
			self.graph[src][dest] = weight
		
		if self.graph[dest]:
			self.graph[dest][src] = weight
		else:
			self.graph[dest] = defaultdict(lambda: None)
			self.graph[dest][src] = weight
		
	# Implement djikstra's algorithm
	def dijkstra(self, src):
		visited = [False] * self.V
		min_dist = [sys.maxsize]*self.V
		last = [-1]*self.V
		
		min_dist[src] = 0
		last[src] = src
		pq = Heap()
		pq.insert(src, min_dist[src])
		
		while not pq.isPqEmpty():
			node, dst_to_node = pq.minimumElement()
			pq.delete()
			
			for adj_node in self.graph[node].keys():
				if min_dist[adj_node] > dst_to_node+self.graph[node][adj_node]:
					min_dist[adj_node] = dst_to_node+self.graph[node][adj_node]
					last[adj_node] = node
					if not visited[adj_node]:
						pq.insert(adj_node, min_dist[adj_node])
			
			visited[node] = True
		return min_dist

# Test your code here 
if __name__ == "__main__": 
    graph = Graph(9)
    graph.addEdge(0, 1, 4)
    graph.addEdge(0, 7, 8)
    graph.addEdge(1, 2, 8)
    graph.addEdge(1, 7, 11)
    graph.addEdge(2, 3, 7)
    graph.addEdge(2, 8, 2)
    graph.addEdge(2, 5, 4)
    graph.addEdge(3, 4, 9)
    graph.addEdge(3, 5, 14)
    graph.addEdge(4, 5, 10)
    graph.addEdge(5, 6, 2)
    graph.addEdge(6, 7, 1)
    graph.addEdge(6, 8, 6)
    graph.addEdge(7, 8, 7)
    dist = graph.dijkstra(0)
    printArr(dist)