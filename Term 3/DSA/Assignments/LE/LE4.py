# -*- coding: utf-8 -*-
"""Copy of LE4_PQ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a9OZJN8WlL5OQabBE3dD4biqEZiF59W9
"""

# Lab Exercise - 4 
# Priority Queues

import sys

class PriorityQueue:

    def __init__(self, maxsize):
      self.maxsize = maxsize
      self.size = 0
      # creating the list with indexing starting from 1 for simplicity
      self.Heap = [0]*(self.maxsize + 1)
      self.Heap[0] = -1 * sys.maxsize
      self.FRONT = 1

    # minHeapify method to minHeapify the node at pos
    def minHeapify(self, pos):
      start_index = pos
      while True:
        if 2*start_index > self.size:
          break
        elif 2*start_index+1 > self.size:
          min_ind = min([start_index, 2*start_index], key=lambda x:self.Heap[x])
        else:
          min_ind = min([start_index, 2*start_index, 2*start_index+1], key=lambda x:self.Heap[x])
        
        if min_ind == start_index:
          break
        self.Heap[min_ind], self.Heap[start_index] = self.Heap[start_index], self.Heap[min_ind]
        start_index = min_ind


    # Write this function to insert a node into the heap
    def insert(self, element):
      if self.size == self.maxsize:
        print('Heap is full')
        return
      self.size+=1
      self.Heap[self.size] = element
      

      x = self.size//2
      while x>=1:
        self.minHeapify(x)
        x=x//2


    # Write this function to delete the rootNode
    def delete(self):
      if self.isPqEmpty():
        print('Heap is empty')
        return
      
      
      
      self.Heap[self.size], self.Heap[1] = self.Heap[1], self.Heap[self.size]
      root_val = self.Heap[self.size]
      self.Heap[self.size] = 0
      self.size-=1
      self.minHeapify(1)
      # return root_val
      
      

    # Write this function to return the rootNode (here the minimum element in PQ)
    def minimumElement(self): 
      return self.Heap[self.FRONT]

    # Write this function to return the size of the PriorityQueue
    def sizeOfPq(self): 
      return self.size

    # Write this function to return if the priorityQueue is empty or not
    # Return boolean value
    def isPqEmpty(self):
      return self.size<=0

    # Function to print the contents of the heap
    def printPriorityQueue(self):
      for i in range(1, (self.size//2)+1):
        print("Parent : "+ str(self.Heap[i])+" Left Child : "+
                  str(self.Heap[2 * i])+" Right Child : "+
                  str(self.Heap[2 * i + 1]))

    # Function to build the PriorityQueue using minHeap
    def priorityQueue(self):
      for pos in range(self.size//2, 0, -1):
        self.minHeapify(pos)

# To verify your functions written above, run this code block

if __name__ == "__main__":

    # Creating a priorityQueue with maxsize = 40 using a MinHeap
    pq = PriorityQueue(40)  
      
    pq.insert(38)
    pq.insert(65)
    pq.insert(32)
    pq.insert(88)
    pq.insert(6)
    pq.insert(24)
    pq.insert(81)
    pq.insert(99)
    pq.insert(3)
    pq.insert(79)
    pq.insert(36)
    pq.insert(57)
    pq.insert(7)
    pq.insert(50)
    pq.insert(55)
    pq.insert(70)
    pq.insert(94)
    pq.insert(28)

    pq.printPriorityQueue()
    print()
    print("The minimum element in the Priority Queue is : ", pq.minimumElement())
    print()
    print("The size of the Priority Queue is: ", pq.sizeOfPq())
    print()
    if pq.isPqEmpty(): 
      print("The Priority Queue is empty")
    else: 
      print("The Priority Queue is not empty")
    print()
    print("Now, delete the root node of the Priority Queue.")
    pq.delete()
    print("After deleting, the minimum element in the Priority Queue is ", pq.minimumElement())
    print()
    pq.printPriorityQueue()

pq = PriorityQueue(3)  
  
pq.insert(32)
pq.insert(65)
pq.insert(70)
pq.printPriorityQueue()
pq.delete()
pq.printPriorityQueue()
pq.minimumElement()

pq = PriorityQueue(3)  
  
pq.insert(32)
pq.insert(65)
pq.insert(70)
pq.printPriorityQueue()
pq.delete()
pq.printPriorityQueue()
pq.minimumElement()