# -*- coding: utf-8 -*-
"""Copy of LE3_BST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gp0Qt4j_fx3SVRDlQlmVzWAe_XBaF1gp
"""

import random

class BST_Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.key = key


    # Insert method to create nodes
    def insert(self, key):
      '''
      node = self
      while True: 
        if key <= node.key:
          if not node.left:
            new_node = BST_Node(key)
            node.left = new_node
            break
          else:
            node=node.left
        else: 
          if not node.right:
            new_node = BST_Node(key)
            node.right = new_node
            break
          else:
            node=node.right
      '''
      # Recursively insert in left or right subtree based on if the key is smaller than current element or larger
      if key <= self.key:
        if not self.left:
          self.left = BST_Node(key)
        else:
          self.left.insert(key)
      else:
        if not self.right:
          self.right = BST_Node(key)
        else:
          self.right.insert(key)


    # Delete method to delete nodes based on key
    def delete(self, key):
      # Delete from left or right subtree based on if the key is smaller than current element or larger
      if key < self.key:
        if not self.left:
          print('Invalid Deletion')
        else:
          self.left = self.left.delete(key)
      elif key > self.key:
        if not self.right:
          print('Invalid Deletion')
        else:
          self.right = self.right.delete(key)
      elif key == self.key:
        # If node to be deleted has both left and right subchild then bring the rightmost element of left subtree to the current position
        if not self.left and not self.right:
          return None
        elif not self.left:
          temp = self.right
          self.right=None
          return temp
        elif not self.right:
          temp = self.left
          return temp
        else:
          prev = None
          node = self.left
          while node.right != None:
            prev = node
            node = node.right
          if prev:
            prev.right = node.left
          else:
            self.left = node.left
          
          node.key,self.key = self.key, node.key
          
          node.left=None
          
          return self
      return self
    
    '''
    def size(self):
      if not self.left and not self.right:
        return 1
      elif not self.left:
        return self.right.size()
      elif not self.right:
        return self.left.size()
      else:
        return 1+max(self.left.size(), self.right.size())
    '''

    # Find method to compare the value with nodes
    def find(self, lkpkey):
      # Recursively find in left or right subtree based on if the key is smaller than current element or larger
      if self.key == lkpkey:
        return True
      elif lkpkey < self.key:
        if not self.left:
          return False
        else:
          return self.left.find(lkpkey)
      else:
        if not self.right:
          return False
        else:
          return self.right.find(lkpkey)


    # Print the tree in order
    def PrintTree(self):
        if self.left:
            self.left.PrintTree()
        print(self.key)
        if self.right:
            self.right.PrintTree()



if __name__ == '__main__':
  # Helper code for million point insertion
  '''
  random.seed(100)
  root = BST_Node(1)
  for i in random.sample(range(-1000000, 1000000), 1000000):
      root.insert(i)
  '''

  # Create 16 element BST
  root = BST_Node(random.randint(1,100))
  for i in range(15):
    root.insert(random.randint(1,100))
  root.PrintTree()
  print()

  # Successful Search
  lkpkey = root.left.key if root.left else root.right.key
  if root.find(lkpkey):
    print('Found', lkpkey)
  else:
    print('Not Found', lkpkey)
  print()

  # Unsuccessful Search
  if root.find(101):
    print('Found', 101)
  else:
    print('Not Found', 101)
  print()

  # Unsuccessful Delete
  print('Del Key:', 101)
  root = root.delete(101)
  print()

  # Successful Delete
  del_key = root.left.key if root.left else root.right.key
  print('Del Key:', del_key)
  print('------------------------')
  root = root.delete(del_key)
  root.PrintTree()