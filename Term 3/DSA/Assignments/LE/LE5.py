# -*- coding: utf-8 -*-
"""Copy of LE5_Sort.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ll9e6KTYIfPYDPeYayDRCezzlv9gFaAN
"""

# Lab Exercise 5 

# Implementing Radix Sort
def radixSort(array):
  # Write your code here
  if not array:
    return

  # To deal with negative elements
  arr_min = 0 if min(array) >=0 else -min(array)
  for i in range(len(array)):
    array[i]+=arr_min

  max_dig = len(str(max(array)))
  out = [0]*len(array)
  i=0

  while i<max_dig:
    count = [0]*10
    start_pos = [0]*10
    for ele in array:
      count[(ele//(10**i))%10]+=1
        
    for j in range(1, len(start_pos)):
      start_pos[j] = start_pos[j-1]+count[j-1]
    
    for ele in array:
      ind = (ele//(10**i))%10
      out[start_pos[ind]] = ele
      start_pos[ind]+=1

    array[:] = out
    i+=1
  
  for i in range(len(array)):
    array[i]-=arr_min

# Test your radixSort function here 
import random

if __name__ == "__main__":

  data = [121, 432, 564, 23, 1, 45, 788]
  radixSort(data)
  print(data)

# Implement Insertion sort using Priority Queues

import sys
import numpy as np

# Use the PriorityQueue class from LE4 here
# to make use of the insert and delete functions 
class PriorityQueue:

    def __init__(self, maxsize):
      self.maxsize = maxsize
      self.size = 0
      # creating the list with indexing starting from 1 for simplicity
      self.Heap = [0]*(self.maxsize + 1)
      self.Heap[0] = -1 * sys.maxsize
      self.FRONT = 1

    # minHeapify method to minHeapify the node at pos
    def minHeapify(self, pos):
      start_index = pos
      while True:
        if 2*start_index > self.size:
          break
        elif 2*start_index+1 > self.size:
          min_ind = min([start_index, 2*start_index], key=lambda x:self.Heap[x])
        else:
          min_ind = min([start_index, 2*start_index, 2*start_index+1], key=lambda x:self.Heap[x])
        
        if min_ind == start_index:
          break
        self.Heap[min_ind], self.Heap[start_index] = self.Heap[start_index], self.Heap[min_ind]
        start_index = min_ind


    # Write this function to insert a node into the heap
    def insert(self, element):
      if self.size == self.maxsize:
        print('Heap is full')
        return
      self.size+=1
      self.Heap[self.size] = element
      

      x = self.size//2
      while x>=1:
        self.minHeapify(x)
        x=x//2


    # Write this function to delete the rootNode
    def delete(self):
      if self.isPqEmpty():
        print('Heap is empty')
        return
      
      
      
      self.Heap[self.size], self.Heap[1] = self.Heap[1], self.Heap[self.size]
      root_val = self.Heap[self.size]
      self.Heap[self.size] = 0
      self.size-=1
      self.minHeapify(1)
      # return root_val
      
      

    # Write this function to return the rootNode (here the minimum element in PQ)
    def minimumElement(self): 
      return self.Heap[self.FRONT]

    # Write this function to return the size of the PriorityQueue
    def sizeOfPq(self): 
      return self.size

    # Write this function to return if the priorityQueue is empty or not
    # Return boolean value
    def isPqEmpty(self):
      return self.size<=0

    # Function to print the contents of the heap
    def printPriorityQueue(self):
      for i in range(1, (self.size//2)+1):
        print("Parent : "+ str(self.Heap[i])+" Left Child : "+
                  str(self.Heap[2 * i])+" Right Child : "+
                  str(self.Heap[2 * i + 1]))

    # Function to build the PriorityQueue using minHeap
    def priorityQueue(self):
      for pos in range(self.size//2, 0, -1):
        self.minHeapify(pos)


class InsertionSort:
  # Implement Insertion Sort based on Priority Queue
  def insertionSort(array): 
    # Write your code here
    ans = [0]*len(array)
    pq = PriorityQueue(len(array)+1)
    
    for ele in array:
      pq.insert(ele)
    
    i = 0
    while not pq.isPqEmpty():
      ans[i] = pq.minimumElement()
      pq.delete()
      i+=1

    return ans

# Test your code here

if __name__ == "__main__":
  data = [-121, 432, 564, 23, 1, 45, 788]
  ans = InsertionSort.insertionSort(data)
  print(ans)