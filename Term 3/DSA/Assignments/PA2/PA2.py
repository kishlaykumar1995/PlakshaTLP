# -*- coding: utf-8 -*-
"""Copy of PA2_PriorityQueue.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KPgEJwBR5fWPzmy1RhIWYFpUiJnBLWzY
"""

# Template class for list based priority queues
# Use this template and rename for each of the implementations

import sys
from collections import deque

class UnsortedPQ:
    def __init__(self):
      # creating the list with indexing starting from 1 for simplicity
      self.size = 0
      self.Heap = []

    # minHeapify method to minHeapify the node at pos
    def minHeapify(self, pos):
      pass

    # Write this function to insert a node into the heap
    def insert(self, element):
      self.size+=1
      self.Heap.append(element)

    # Write this function to delete the rootNode
    def delete(self):
      if self.isPqEmpty():
        print('Heap is empty')
        return
       
      min = 0
      for pos in range(self.size):
        if self.Heap[pos] < self.Heap[min]:
          min = pos
      
      self.size-=1
      return self.Heap.pop(min)

    # Write this function to return the rootNode (here the minimum element in PQ)
    def minimumElement(self):
      if self.isPqEmpty():
        print('Heap is empty')
        return
       
      min = 0
      for pos in range(self.size):
        if self.Heap[pos] < self.Heap[min]:
          min = pos
      return self.Heap[min]

    # Write this function to return the size of the PriorityQueue
    def sizeOfPq(self): 
      return self.size

    # Write this function to return if the priorityQueue is empty or not
    # Return boolean value
    def isPqEmpty(self):
      return self.size<=0
    

    # Function to print the contents of the heap
    def printQueue(self):
      for i in range(self.size):
        print(self.Heap[i])

class SortedPQ:

    def __init__(self, maxsize=40):
        self.maxsize = maxsize
        self.size = 0
        # creating the list with indexing starting from 1 for simplicity
        self.Heap = [0]*(self.maxsize + 1)
        self.Heap[0] = -1 * sys.maxsize
        self.FRONT = 1

    # minHeapify method to minHeapify the node at pos
    def minHeapify(self, pos):
      while pos>=2:
        if self.Heap[pos] < self.Heap[pos-1]:
          self.Heap[pos], self.Heap[pos-1] = self.Heap[pos-1], self.Heap[pos]
        else:
           break
        pos-=1


    # Write this function to insert a node into the heap
    def insert(self, element):
      if self.size >= self.maxsize:
        self.Heap = self.Heap + [0]*self.maxsize
        self.maxsize = len(self.Heap) - 1
      
      self.size+=1
      self.Heap[self.size] = element
      self.minHeapify(self.size)

    # Write this function to delete the rootNode
    def delete(self):
      if self.isPqEmpty():
        print('Heap is empty')
        return
      
      self.size-=1
      return self.Heap.pop(self.FRONT)

    # Write this function to return the rootNode (here the minimum element in PQ)
    def minimumElement(self): 
      if self.isPqEmpty():
        print('Heap is empty')
        return

      return self.Heap[self.FRONT]

    # Write this function to return the size of the PriorityQueue
    def sizeOfPq(self): 
        return self.size

    # Write this function to return if the priorityQueue is empty or not
    # Return boolean value
    def isPqEmpty(self):
        return self.size <= 0

    # Function to print the contents of the heap
    def printQueue(self):
      for i in range(self.size):
        print(self.Heap[i])

# Template class for tree based priority queues

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        self.parent = None 

class HeapPQ:
    def __init__(self):
        self.head = None
        self.size = 0
    
    '''
    def insert_down_heapify(self, value):
      if self.isPqEmpty():
        self.head = Node(value)
        self.size+=1
        return
      
      self.size+=1
      path = []
      i = self.size
      
      while i>1:
        if i%2 == 0:
          path.append('L')
        else:
          path.append('R')
        i//=2
      path = path[::-1]

      node = self.head
      for ele in path[:-1]:
        if ele == 'L':
          node = node.left
        else:
          node = node.right
      
      new_node = Node(value)
      new_node.parent = node
      if path[-1] == 'L':
        node.left = new_node
      else:
        node.right = new_node
      
      x = new_node
      while x.parent:
        self.minHeapifyDown(x.parent)
        x = x.parent
    '''

    def insert(self, value):
      if self.isPqEmpty():
        self.head = Node(value)
        self.size+=1
        return
      
      self.size+=1
      path = []
      i = self.size
      
      while i>1:
        if i%2 == 0:
          path.append('L')
        else:
          path.append('R')
        i//=2
      path = path[::-1]

      node = self.head
      for ele in path[:-1]:
        if ele == 'L':
          node = node.left
        else:
          node = node.right
      
      new_node = Node(value)
      new_node.parent = node
      if path[-1] == 'L':
        node.left = new_node
      else:
        node.right = new_node
      
      self.minHeapifyUp(new_node)

    def delete(self):
      if self.isPqEmpty():
        print('Heap is empty.')
        return
      elif self.size == 1:
        self.head = None
        self.size-=1
        return
      
      path = []
      i = self.size
      
      while i>1:
        if i%2 == 0:
          path.append('L')
        else:
          path.append('R')
        i//=2
      path = path[::-1]
      
      node = self.head
      for ele in path[:-1]:
        if ele == 'L':
          node = node.left
        else:
          node = node.right
      
      if path[-1] == 'L':
        self.head.value, node.left.value = node.left.value, self.head.value
        node.left.parent = None
        node.left = None
      else:
        self.head.value, node.right.value = node.right.value, self.head.value
        node.right.parent = None
        node.right = None
      
      self.size-=1
      self.minHeapifyDown(self.head)
    
    def minHeapifyDown(self, node):
      if node.left == None and node.right == None:
        return
      elif node.right == None:
        if node.value > node.left.value:
          node.value, node.left.value = node.left.value, node.value
          # self.minHeapifyDown(node.left)
        return
      else:
        min_node = min([node, node.left, node.right], key = lambda x:x.value)
        if min_node == node:
          return
        node.value, min_node.value = min_node.value, node.value
        self.minHeapifyDown(min_node)
    
    def minHeapifyUp(self, node):
      while node != self.head:
        if node.value < node.parent.value:
          node.value, node.parent.value = node.parent.value, node.value
        else:
          break
        node = node.parent

    def peek(self):
      if self.isPqEmpty():
        return
      return self.head.value
    
    def sizeOfPq(self): 
      return self.size

    def isPqEmpty(self):
      return not self.head

    def printQueue(self):
      if not self.head:
        return
      
      q = deque()
      q.append(self.head)
      while q:
        node = q.popleft()
        print(node.value)
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)

class HeapPQBottomUp:
    def __init__(self):
        self.head = None
        self.size = 0

    def construct_heap(self, lst):
      if self.isPqEmpty()and len(lst)==1:
        self.head = Node(lst[0])
        self.size+=1
        return
      
      self.size = len(lst)
      self.head = self.construct_heap_recursive(lst)
      
    def construct_heap_recursive(self, lst):
      if not len(lst):
        return None
      elif len(lst) == 1:
        node = Node(lst[0])
        return node
      
      k = lst[0]
      node = Node(k)
      lst = lst[1:]

      lft,rgt = 0,0
      count=len(lst)
      i = 0
      while True:
        if count-2**i<=0:
          lft+=count
          break
        lft+=2**i
        count-=2**i
        if count-2**i<=0:
          rgt+=count
          break
        rgt+=2**i
        count-=2**i
        i+=1
      # lft = len(lst)//2

      node.left = self.construct_heap_recursive(lst[:lft])
      if node.left:
        node.left.parent = node
      node.right = self.construct_heap_recursive(lst[lft:])
      if node.right:
        node.right.parent = node
      
      self.minHeapifyDown(node)
      return node

    def delete(self):
      if self.isPqEmpty():
        print('Heap is empty.')
        return
      elif self.size == 1:
        self.head = None
        self.size-=1
        return
      
      path = []
      i = self.size
      
      while i>1:
        if i%2 == 0:
          path.append('L')
        else:
          path.append('R')
        i//=2
      path = path[::-1]
      
      node = self.head
      for ele in path[:-1]:
        if ele == 'L':
          node = node.left
        else:
          node = node.right
      
      if path[-1] == 'L':
        self.head.value, node.left.value = node.left.value, self.head.value
        node.left.parent = None
        node.left = None
      else:
        self.head.value, node.right.value = node.right.value, self.head.value
        node.right.parent = None
        node.right = None
      
      self.size-=1
      self.minHeapifyDown(self.head)
    
    def minHeapifyDown(self, node):
      if node.left == None and node.right == None:
        return
      elif node.right == None:
        if node.value > node.left.value:
          node.value, node.left.value = node.left.value, node.value
          # self.minHeapifyDown(node.left)
        return
      else:
        min_node = min([node, node.left, node.right], key = lambda x:x.value)
        if min_node == node:
          return
        node.value, min_node.value = min_node.value, node.value
        self.minHeapifyDown(min_node)
    
    def minHeapifyUp(self, node):
      while node != self.head:
        if node.value < node.parent.value:
          node.value, node.parent.value = node.parent.value, node.value
        else:
          break
        node = node.parent

    def peek(self):
      if self.isPqEmpty():
        return
      return self.head.value

    def isPqEmpty(self):
      return not self.head

    def printQueue(self):
      if not self.head:
        return
      
      q = deque()
      q.append(self.head)
      while q:
        node = q.popleft()
        print(node.value)
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)

def main():
  with open('./numbers.txt','r') as f:
    qtype = int(f.readline())
    if qtype == 0:
      pq = UnsortedPQ()
    elif qtype == 1:
      pq = SortedPQ()
    else:
      pq = HeapPQ()
    n = int(f.readline())

    for _ in range(n):
      pq.insert(int(f.readline()))
    
    # print(pq.Heap[:pq.size])
    #pq.delete()
    
    return pq

if __name__ == '__main__':
  main()