# -*- coding: utf-8 -*-
"""PA1_Group7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X_7QZzizd-O9p9vNQfF-9rZOIzlQnSXz
"""

import time
from collections import deque
import matplotlib.pyplot as plt

# Implementing Stacks using Arrays 

class ArrayStack:
    
    # Constructor for ArrayStack class
    def __init__(self, init_size=10):
        # your code here
        if init_size < 0:
          raise Exception("Wrong Initial size")
        
        self.arr_stack = [None]*init_size             # Initialize with an input size
        self.pointer = -1
        

    # Push: Adds a new element at the back of the list
    def push(self, element):
        # your code here
        self.pointer+=1                               

        if self.pointer > len(self.arr_stack)-1:
          self.arr_stack = self.arr_stack + [None]*1000                   # If stack is full then increment size by 1000
        
        self.arr_stack[self.pointer] = element



    # Pop: Deletes the element at the last and returns the value of it
    def pop(self):
        # your code here
        if self.isEmpty():
          return None                               # Return None if stack is empty else remove the last element
        else:
          dl = self.arr_stack[self.pointer]
          self.arr_stack[self.pointer] = None
          self.pointer-=1
          return dl


    # Returns the size of the stack
    def size(self):
        # your code here
        return self.pointer+1


    # Return the element at the top of the stack without removing it
    def top(self):
      if self.isEmpty():
          return None                            # Show the last element if it exists or show None
      else:
        return self.arr_stack[self.pointer]
        


    # Returns true is stack is empty, False if not
    def isEmpty(self):
        # your code here
        if not self.size():
          return True
        return False


    def printIsEmpty(self):
        print("\nStack is Empty\n") if self.isEmpty() else print("\nStack is not Empty\n")


    def printStack(self):
      # Print the stack (list appends forward so reverse order)
        if not self.isEmpty():
          print("Stack: ", self.arr_stack[self.pointer::-1])
        else:
          print("Stack: ",[])


# Implementing Stacks using Arrays 

class DoublingArrayStack:
    
    # Constructor for ArrayStack class
    def __init__(self, init_size=10):
        # your code here
        if init_size <= 0:
          raise Exception("Wrong Initial size")
        
        self.dbl_arr_stack = [None]*init_size
        self.pointer = -1
        

    # Push: Adds a new element at the back of the list
    def push(self, element):
        # your code here
        self.pointer+=1
        if self.pointer > len(self.dbl_arr_stack)-1:
          self.dbl_arr_stack = self.dbl_arr_stack + [None]*self.size()          # If stack is full then double the size
        
        self.dbl_arr_stack[self.pointer] = element



    # Pop: Deletes the element at the last and returns the value of it
    def pop(self):
        # your code here
        if self.isEmpty():
          return None
        else:
          dl = self.dbl_arr_stack[self.pointer]
          self.dbl_arr_stack[self.pointer] = None
          self.pointer-=1
          return dl


    # Returns the size of the stack
    def size(self):
        # your code here
        return self.pointer+1


    # Return the element at the top of the stack without removing it
    def top(self):
      if self.isEmpty():
          return None
      else:
        return self.dbl_arr_stack[self.pointer]
        


    # Returns true is stack is empty, False if not
    def isEmpty(self):
        # your code here
        if not self.size():
          return True
        return False


    def printIsEmpty(self):
        print("\nStack is Empty\n") if self.isEmpty() else print("\nStack is not Empty\n")


    def printStack(self):
        if not self.isEmpty():
          print("Stack: ", self.dbl_arr_stack[self.pointer::-1])
        else:
          print("Stack: ",[])

# Implementing Stacks Linked Lists

# Node class for the individual nodes
class Node:

    # constructor for Node class
    def __init__(self, data):
        # your code here
        self.data = data
        self.next = None
 

# Manager class to link the nodes and manage the overall list
class LinkedListStack:

    # constructor for LinkedListStack class
    def __init__(self):
        # your code here
        self.head = None
        self.counter = -1


    # Push: Adds a new element at the back of the list
    def push(self, data):
        # your code here
        if self.isEmpty():                              # If stack is empty assign it to head or insert a new element at the head position
            self.head = Node(data)
        else:
            new_node = Node(data)
            new_node.next = self.head
            self.head = new_node
        
        self.counter += 1


    # Pop: Deletes the element at the last and returns the value of it
    def pop(self):
        # your code here
        if self.isEmpty():                              # If list is empty return None, else pop the last element and delete the node
            return None
        else:
            deleted = self.head
            deleted_data = self.head.data
            self.head = self.head.next
            self.counter -= 1
            del deleted
            return deleted_data


    # Returns the size of the stack
    def size(self):
        # your code here
        return self.counter+1


    # Return the element at the top of the stack without removing it
    def top(self): 
        # your code here
        if self.isEmpty():
            return None
        return self.head.data


    # Return true is stack is empty, False if not
    def isEmpty(self):
        # your code here
        if not self.head:
          return True
        return False


    def printIsEmpty(self):
        print("\nStack is Empty\n") if self.isEmpty() else print("\nStack is not Empty\n")

    # Reverses the stack
    def reverseList(self):
        # your code here
        if self.isEmpty() or self.size() == 1:
          return
        
        prev = self.head                              # Start from the head and reverse the node links one-by-one, keeping track of current previous and next(temp) nodes
        cur = self.head.next
        self.head.next = None

        while cur!=None:
          temp = cur.next
          cur.next = prev
          prev = cur
          cur = temp
        
        self.head = prev


    # Print data stored in the stack
    def printStack(self):
        # your code here
        if self.isEmpty():
          print("Stack: ", [])
          return
        
        print('Stack: ', end='[')
        cur = self.head
        while cur.next != None:
          print(cur.data, end=', ')
          cur=cur.next
        print(str(cur.data)+']')