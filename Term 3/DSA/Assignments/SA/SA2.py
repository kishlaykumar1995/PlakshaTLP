# -*- coding: utf-8 -*-
"""Copy of SA2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T3bZF7cbFO36oHl4-NUyo3p25ZNyJyKn

# **Problem - 1: Consecutive parent-child numbers**

Given a binary tree with root node A, return the number of parent-child pairs which are consecutive numbers such that parent = child - 1. 


Example : 


    Input: 

         4
        / \
       8   5
      /  \
    9    77


    Output : 2

    Explanation : There are only 2 pairs of parent-child which are consecutive numbers. 
    Tha pairs are (4,5) and (8,9)
"""

# Consecutive parent-child numbers in a binary tree

class Node: 
  def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None

class Solution1: 
  # Write this function to return the number of parent-child pairs 
  # which are consecutive numbers

  # Comment out pass and write the code here
  def consecutiveNodes(self, A): 
      return self.consNodesRec(A, 0)
  
  def consNodesRec(self, A, count=0):
    if A == None:
      return 0
    
    if A.left and (A.val == A.left.val-1 or A.val-1 == A.left.val):
      count+=1
    if A.right and (A.val == A.right.val-1 or A.val-1 == A.right.val):
      count+=1
    
    count+=self.consNodesRec(A.left, 0)
    count+=self.consNodesRec(A.right, 0)
    return count

# Execute this codeblock to verify your results

if __name__ == '__main__':
    root = Node(16)
    root.left = Node(17)
    root.right = Node(30)
    root.left.left = Node(18)
    root.left.right = Node(25)
    root.right.left = Node(87)
    root.right.right = Node(31)
    root.left.left.left = Node(45)
    root.left.left.right = Node(19)
    root.left.right.left = Node(26)
    root.left.right.right = Node(90)
    root.right.left.left = Node(76)
    root.right.left.right = Node(66)
    root.right.right.left = Node(27)
    root.right.right.right = Node(32)
    
    # root = Node(4)
    # root.left = Node(8)
    # root.right = Node(5)
    # root.left.left = Node(8)
    # root.left.right = Node(9)

    print(Solution1().consecutiveNodes(root))

"""# **Problem - 2: Reverse Level Order Traversal**

Given the root of a Binary tree, return the reverse Level Order traversal. 


Example : 


    Input: 

         4
        / \
       8   71
          /  \
         96   34


    Output : [96 34 8 71 4]

    Explanation : Level 3 -> 96, 34. Level 2 -> 8, 71 and Level 1 -> 4 . 
    So, the overall reverse level order traversal is [96 34 8 71 4]
"""

# Reverse Level Order Traversal

from collections import deque

class Node: 
  def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None

class Solution2: 
  # Comment out pass and write your code here
  def reverseLevelOrder(self, A):    
    levelOrderTraversal = []
    levels = []
    q = deque()
    reverseOrderedList = deque()
    q.append(A)
    while q:
      node = q.popleft()
      reverseOrderedList.appendleft(node.val)
      if node.right:
        q.append(node.right)
      if node.left:
        q.append(node.left)
    
    return list(reverseOrderedList)

# Execute this codeblock to verify your results

if __name__ == '__main__':
    root = Node(16)
    root.left = Node(17)
    root.right = Node(30)
    root.left.left = Node(18)
    root.left.right = Node(25)
    root.right.left = Node(87)
    root.right.right = Node(31)
    root.left.left.left = Node(45)
    root.left.left.right = Node(19)
    root.left.right.left = Node(26)
    root.left.right.right = Node(90)
    root.right.left.left = Node(76)
    root.right.left.right = Node(66)
    root.right.right.left = Node(27)
    root.right.right.right = Node(32)
    # root = Node(None)

    print(Solution2().reverseLevelOrder(root))

