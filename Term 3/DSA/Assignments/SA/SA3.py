# -*- coding: utf-8 -*-
"""Copy of SA3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ios8AumeZ2wYcnjTJufOI313Bjszoprm

## Problem 1 : Determine if an array is a subset of another array

Given two arrays: A[0..m-1] and B[0..n-1] write a program for determining whether B is a subset of A. Assume that the arrays are not in sorted order and made up of integers. Use Hashtable with chaining.
"""

# Function to return true if arr2 is a subset of arr1
class HashTableChained:
    def __init__(self, size=50):
        self.size = size
        self.table = [None] * size
        self.g = 31
    
    # hash function to determine the index for a given key
    def hash_function(self, key):
      hash = key
      hash += self.g * hash
      index = hash % self.size     
      return index
    
    # insert a key-value pair to the hash table
    def insert(self, key):
      index = self.hash_function(key)
      if not self.table[index]:
        self.table[index] = []
        self.table[index].append(key)
        return
      else:
        self.table[index].append(key)
      
    # retrieve the value for a given key
    def search(self, key):
      index = self.hash_function(key)
      if not self.table[index]:
        return False               # Or should we return -1?
      for ele in self.table[index]:
        if ele == key:
          return True
    
    def delete(self, key):
      index = self.hash_function(key)
      if not self.table[index]:
        return None
      for ele in self.table[index]:
        if ele == key:
          self.table[index].remove(ele)

def isSubset(arr1, arr2):
    # comment out pass and add code here
    # if len(arr2) > len(arr1):
    #   return False
    
    htc = HashTableChained()
    for ele in arr1:
      htc.insert(ele)
    
    for ele in arr2:
      # print(ele, htc.search(ele))
      if not htc.search(ele):
        return False
      htc.delete(ele)

    return True

# Test your code here

if __name__ == '__main__':
	arr1 = [11, 3, 7]
	arr2 = [11, 3, 7, 11]

	if (isSubset(arr1, arr2)):
		print("arr2 is subset of arr1")
	else:
		print("arr2 is not a subset of arr1")

"""## Problem 2 : Kth largest element in an unsorted array

Given an unsorted array of integers, find out the kth largest element in it using Priority Queue. 

Below given is a starter code to use a min Heap in PriorityQueue. Create a Priority Queue from below class and write your code.
"""

# Helper Code

# Use this Priority Queue class in the kthSmallest method 
import sys
class PriorityQueue:

  # Constructor
	def __init__(self, arr, size):
		# list of elements in the heap
		self.harr = arr
		self.capacity = None
		self.heap_size = size

		i = int((self.heap_size - 1) / 2)
		while i >= 0:
			self.minHeapify(i)
			i -= 1

	def parent(self, i):
		return (i - 1) / 2

	def left(self, i):
		return 2 * i + 1

	def right(self, i):
		return 2 * i + 2

	# Returns minimum
	def getMin(self):
		return self.harr[0]

	# Method to remove minimum element (or root) from min heap
	def extractMin(self):
		if self.heap_size == 0:
			return float("inf")

		# Store the minimum value
		root = self.harr[0]

		# If there are more than 1 items, move the last item to root and call heapify
		if self.heap_size > 1:
			self.harr[0] = self.harr[self.heap_size - 1]
			self.minHeapify(0)
		self.heap_size -= 1
		return root

	# A method to heapify a subtree with root at given index.
	def minHeapify(self, i):
		# comment out pass and add code here
		if(i < self.heap_size):
			leftChildIndex = self.left(i)
			rightChildIndex = self.right(i)
			if(leftChildIndex < self.heap_size and rightChildIndex < self.heap_size):
				leftChild = self.harr[leftChildIndex]
				rightChild = self.harr[rightChildIndex]
				if(leftChild < rightChild and leftChild < self.harr[i]):
					self.harr[i], self.harr[leftChildIndex] = self.harr[leftChildIndex], self.harr[i]
					self.minHeapify(leftChildIndex)
				elif(rightChild < leftChild and rightChild < self.harr[i]):
					self.harr[i], self.harr[rightChildIndex] = self.harr[rightChildIndex], self.harr[i]
					self.minHeapify(rightChildIndex)
			elif(leftChildIndex < self.heap_size and rightChildIndex > self.heap_size):
				leftChild = self.harr[leftChildIndex]
				if(leftChild < self.harr[i]):
					self.harr[i], self.harr[leftChildIndex] = self.harr[leftChildIndex], self.harr[i]
					self.minHeapify(leftChildIndex)
			elif(leftChildIndex > self.heap_size and rightChildIndex < self.heap_size):
				rightChild = self.harr[rightChildIndex]
				self.harr[i], self.harr[rightChildIndex] = self.harr[rightChildIndex], self.harr[i]
				self.minHeapify(rightChildIndex)

# Function to return the kth largest element in the array

def kthLargest(arr, N, K):
    # comment out pass and add code here
    minHeap = PriorityQueue(arr, N)
    #N = 9 ,k = 3, 
    K = N-K+1
    if K > N:
        return None
    ans = None
    while(K > 0):
        ans = minHeap.extractMin()
        K -= 1
    return ans

# Test your code by running this code block

if __name__ == '__main__':
	arr = [12, 3, 5, 7, 19, 34, 44, 8]
	N = len(arr)
	K = 4

	print("{}th largest element is".format(K), kthLargest(arr, N, K))

